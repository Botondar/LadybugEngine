#version 460 core

#include "common.glsli"

LayoutGroupSize(LightBin);

SetBindingLayout(PerFrame, Constants, scalar)
uniform PerFrameBlock
{
    per_frame PerFrame;
};

SetBindingLayout(PerFrame, LightBuffer, scalar)
readonly buffer LightBuffer
{
    light Lights[];
};

SetBindingLayout(PerFrame, TileBuffer, scalar)
buffer TileBuffer
{
    screen_tile Tiles[];
};

SetBinding(PerFrame, StructureImage) uniform texture2D StructureImage;

bool IntersectAABBSphere(v3 P, v3 HalfExtent, v3 C, float R)
{
    v3 dP = max(v3(0.0), abs(P - C) - HalfExtent);
    bool Result = dot(dP, dP) <= R*R;
    return(Result);
}

void main()
{
    if (gl_GlobalInvocationID.x < PerFrame.TileCount.x)
    {
        uint TileIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * PerFrame.TileCount.x;
        uint uMinX = gl_GlobalInvocationID.x * R_TileSizeX;
        uint uMinY = gl_GlobalInvocationID.y * R_TileSizeY;
        uint uMaxX = uMinX + R_TileSizeX;
        uint uMaxY = uMinY + R_TileSizeY;

        mat2 ProjectZ = mat2(PerFrame.ProjectionTransform[2].zw, PerFrame.ProjectionTransform[3].zw);

        float Depths[R_TileSizeX*R_TileSizeY];
        float MinDepth = 1e9;
        float MaxDepth = 0.0;
        float MinDepthClipSpace = 1.0;
        float MaxDepthClipSpace = 0.0;
        for (uint Y = 0; Y < R_TileSizeY; Y++)
        {
            for (uint X = 0; X < R_TileSizeX; X++)
            {
                vec2 Depth2 = texelFetch(StructureImage, ivec2(uMinX + X, uMinY + Y), 0).zw;
                float Depth = Depth2.x + Depth2.y;
                MinDepth = min(Depth, MinDepth);
                MaxDepth = max(Depth, MaxDepth);

                vec2 ProjDepth2 = ProjectZ * vec2(Depth, 1.0);
                float ProjDepth = ProjDepth2.x / ProjDepth2.y;
                MinDepthClipSpace = min(ProjDepth, MinDepthClipSpace);
                MaxDepthClipSpace = max(ProjDepth, MaxDepthClipSpace);

                uint Index = X + Y*R_TileSizeX;
                Depths[Index] = Depth;
            }
        }

        float InvDepthRange = 1.0 / (MaxDepth - MinDepth);
        float DepthOffset = MinDepth;
        uint DepthSliceMask = 0;
        for (uint Index = 0; Index < R_TileSizeX*R_TileSizeY; Index++)
        {
            float Depth = clamp(InvDepthRange * (Depths[Index] - DepthOffset), 0.0, 1.0);
            uint DepthSlice = uint(floor(32.0 * Depth));
            DepthSliceMask |= 1 << DepthSlice;
        }

        float MinX = 2.0 * (float(uMinX) / PerFrame.ScreenSize.x) - 1.0;
        float MinY = 2.0 * (float(uMinY) / PerFrame.ScreenSize.y) - 1.0;
        float MaxX = 2.0 * (float(uMaxX) / PerFrame.ScreenSize.x) - 1.0;
        float MaxY = 2.0 * (float(uMaxY) / PerFrame.ScreenSize.y) - 1.0;

        v4 P0 = PerFrame.InverseProjectionTransform * v4(MinX, MinY, MinDepthClipSpace, 1.0);
        v4 P1 = PerFrame.InverseProjectionTransform * v4(MaxX, MaxY, MaxDepthClipSpace, 1.0);
        P0.xyz /= P0.w;
        P1.xyz /= P1.w;
        v3 MinP = min(P0.xyz, P1.xyz);
        v3 MaxP = max(P0.xyz, P1.xyz);

        v3 BoxP = 0.5 * (MaxP + MinP);
        v3 HalfExtent = 0.5 * (MaxP - MinP);

        uint LightCount = 0;
        for (uint LightIndex = 0; LightIndex < PerFrame.LightCount; LightIndex++)
        {
            if (LightCount == R_MaxLightCountPerTile) break;

            v3 P = Lights[LightIndex].P.xyz;
            v3 E = Lights[LightIndex].E;
            float L = GetLuminance(E);
            float R = sqrt(max(L / R_LuminanceThreshold, 0.0));

            if (IntersectAABBSphere(BoxP, HalfExtent, P, R))
            {
                // NOTE(boti): Shadow casting lights also participate in volumetrics,
                // so we don't want to depth cull those
                if (Lights[LightIndex].ShadowIndex != 0xFFFFFFFFu)
                {
                    Tiles[TileIndex].LightIndices[LightCount++] = LightIndex;
                }
                else
                {
                    float MaxZ = clamp(InvDepthRange * (P.z + R - DepthOffset), 0.0, 1.0);
                    float MinZ = clamp(InvDepthRange * (P.z - R - DepthOffset), 0.0, 1.0);

                    uint MaxSlice = uint(floor(32.0 * MaxZ));
                    uint MinSlice = uint(floor(32.0 * MinZ));

                    uint Mask = (0xFFFFFFFFu >> (31 - (MaxSlice - MinSlice))) << MinSlice;
                    if ((DepthSliceMask & Mask) != 0)
                    {
                        Tiles[TileIndex].LightIndices[LightCount++] = LightIndex;
                    }
                }
            }
        }
        Tiles[TileIndex].LightCount = LightCount;
    }
}