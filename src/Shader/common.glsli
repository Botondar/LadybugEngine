#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_16bit_storage : require

#define PI 3.14159265359
#define ALPHA_TEST_THRESHOLD 0.5

#define f32 float
#define v2 vec2
#define v3 vec3
#define v4 vec4
#define m2 mat2
#define m3 mat3
#define m4 mat4

// TODO(boti): Create a shared header between the C++ and the shaders
// NOTE(boti): These constants need to be kept in sync with the ones Renderer.hpp
#define R_TileSizeX 16
#define R_TileSizeY 16
#define R_MaxLightCountPerTile 255
#define R_LuminanceThreshold 3e-2
#define R_MaxLightCount 16384

struct light
{
    vec4 P;
    vec4 E;
};

struct screen_tile
{
    uint LightCount;
    uint LightIndices[R_MaxLightCountPerTile];
};

struct per_frame
{
    mat4 CameraTransform;
    mat4 View;
    mat4 Projection;
    mat4 ViewProjection;

    mat4 CascadeViewProjection;
    vec4 CascadeMinDistances;
    vec4 CascadeMaxDistances;
    vec3 CascadeScales[3];
    vec3 CascadeOffsets[3];

    float FocalLength;
    float AspectRatio;
    float NearZ;
    float FarZ;

    vec3 CameraP;
    vec3 SunV;
    vec3 SunL;

    vec2 ScreenSize;

    uint LightCount;
};

struct material
{
    vec3 Emissive;
    uint Diffuse;
    uint MetallicRoughness;
    uint DiffuseID;
    uint NormalID;
    uint MetallicRoughnessID;
};

//
// Common
//

v3 TransformPoint(m4 M, v3 P)
{
    v3 Result = fma(P.xxx, M[0].xyz, fma(P.yyy, M[1].xyz, fma(P.zzz, M[2].xyz, M[3].xyz)));
    return(Result);
}

v3 TransformDirection(m4 M, v3 V)
{
    v3 Result = fma(V.xxx, M[0].xyz, fma(V.yyy, M[1].xyz, V.z * M[2].xyz));
    return(Result);
}

vec4 UnpackRGBA8(in uint Color) 
{
    vec4 Result = vec4(
        (Color & 0xFF) / 255.0,
        ((Color >> 8) & 0xFF) / 255.0,
        ((Color >> 16) & 0xFF) / 255.0,
        (Color >> 24) / 255.0);
    return Result;
}

float GetLuminance(in vec3 Color)
{
    vec3 Factors = vec3(0.212639, 0.715169, 0.072192);
    float Result = dot(Factors, Color);
    return Result;
}

vec3 SetLuminance(in vec3 Color, in vec3 TargetLuminance)
{
    float CurrentLuminance = GetLuminance(Color);
    vec3 Result = Color * (TargetLuminance / CurrentLuminance);
    return Result;
}

//
// PBR shading functions
//
vec3 FresnelSchlick(in vec3 F0, in float CosTheta)
{
    vec3 Result = F0 + (vec3(1.0) - F0) * exp2((-5.55473 * CosTheta - 6.98316) * CosTheta);
    return Result;
}

float DistributionGGX(in float Roughness, in float NdotH)
{
    float Alpha = Roughness*Roughness;
    float Alpha2 = Alpha*Alpha;

    float a = NdotH*NdotH * (Alpha2 - 1.0) + 1.0;
    float Result = Alpha2 / max(PI * a * a, 1e-4);
    return Result;
}

float GeometryGGX(in float Roughness, in float NdotV, in float NdotL)
{
    float k = (Roughness + 1.0);
    k *= k;
    k *= (1.0 / 8.0);

    float G1 = NdotV / (NdotV*(1.0 - k) + k);
    float G2 = NdotL / (NdotL*(1.0 - k) + k);
    float Result = G1*G2;
    return Result;
}

//
// Shadow helpers
//

vec3 GetCascadeBlends(in vec4 MinDistances, in vec4 MaxDistances, in vec3 P)
{
    vec3 Result = vec3(0.0);
    for (uint i = 1; i < 4; i++)
    {
        Result[i - 1] = (P.z - MinDistances[i]) / (MaxDistances[i - 1] - MinDistances[i]);
    }
    return Result;
}

//
// Structure buffer
//

vec3 StructureDecode(in vec4 Structure)
{
    vec3 Result = vec3(Structure.xy, Structure.z + Structure.w);
    return Result;
}