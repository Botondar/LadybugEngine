#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_16bit_storage : require

#define PI 3.14159265359
#define ALPHA_TEST_THRESHOLD 0.5

#define f32 float
#define v2 vec2
#define v3 vec3
#define v4 vec4
#define m2 mat2
#define m3 mat3
#define m4 mat4

// TODO(boti): Create a shared header between the C++ and the shaders
// NOTE(boti): These constants need to be kept in sync with the ones Renderer.hpp
#define R_TileSizeX 16
#define R_TileSizeY 16
#define R_MaxLightCountPerTile 255
#define R_LuminanceThreshold 1e-2
#define R_MaxLightCount 16384

struct light
{
    vec4 P;
    vec4 E;
};

struct screen_tile
{
    uint LightCount;
    uint LightIndices[R_MaxLightCountPerTile];
};

struct per_frame
{
    mat4 CameraTransform;
    mat4 View;
    mat4 Projection;
    mat4 InverseProjection;
    mat4 ViewProjection;

    mat4 CascadeViewProjection;
    float CascadeMinDistances[4];
    float CascadeMaxDistances[4];
    vec3 CascadeScales[3];
    vec3 CascadeOffsets[3];

    float FocalLength;
    float AspectRatio;
    float NearZ;
    float FarZ;

    vec3 CameraP;
    vec3 SunV;
    vec3 SunL;

    vec2 ScreenSize;
    uvec2 TileCount;

    uint LightCount;
};

struct material
{
    vec3 Emissive;
    uint Diffuse;
    uint MetallicRoughness;
    uint DiffuseID;
    uint NormalID;
    uint MetallicRoughnessID;
};

//
// Common
//

v3 TransformPoint(m4 M, v3 P)
{
    v3 Result = fma(P.xxx, M[0].xyz, fma(P.yyy, M[1].xyz, fma(P.zzz, M[2].xyz, M[3].xyz)));
    return(Result);
}

v3 TransformDirection(m4 M, v3 V)
{
    v3 Result = fma(V.xxx, M[0].xyz, fma(V.yyy, M[1].xyz, V.z * M[2].xyz));
    return(Result);
}

vec4 UnpackRGBA8(in uint Color) 
{
    vec4 Result = vec4(
        (Color & 0xFF) / 255.0,
        ((Color >> 8) & 0xFF) / 255.0,
        ((Color >> 16) & 0xFF) / 255.0,
        (Color >> 24) / 255.0);
    return Result;
}

float GetLuminance(in vec3 Color)
{
    vec3 Factors = vec3(0.212639, 0.715169, 0.072192);
    float Result = dot(Factors, Color);
    return Result;
}

vec3 SetLuminance(in vec3 Color, in vec3 TargetLuminance)
{
    float CurrentLuminance = GetLuminance(Color);
    vec3 Result = Color * (TargetLuminance / CurrentLuminance);
    return Result;
}

//
// PBR shading functions
//
vec3 FresnelSchlick(in vec3 F0, in float CosTheta)
{
    vec3 Result = F0 + (vec3(1.0) - F0) * exp2((-5.55473 * CosTheta - 6.98316) * CosTheta);
    return Result;
}

float DistributionGGX(in float Roughness, in float NdotH)
{
    float Alpha = Roughness*Roughness;
    float Alpha2 = Alpha*Alpha;

    float a = NdotH*NdotH * (Alpha2 - 1.0) + 1.0;
    float Result = Alpha2 / max(PI * a * a, 1e-4);
    return Result;
}

float GeometryGGX(in float Roughness, in float NdotV, in float NdotL)
{
    float k = (Roughness + 1.0);
    k *= k;
    k *= (1.0 / 8.0);

    float G1 = NdotV / (NdotV*(1.0 - k) + k);
    float G2 = NdotL / (NdotL*(1.0 - k) + k);
    float Result = G1*G2;
    return Result;
}

//
// Shadow helpers
//

vec3 GetCascadeBlends(in float MinDistances[4], in float MaxDistances[4], in vec3 P)
{
    vec3 Result = vec3(0.0);
    for (uint i = 1; i < 4; i++)
    {
        Result[i - 1] = (P.z - MinDistances[i]) / (MaxDistances[i - 1] - MinDistances[i]);
    }
    return Result;
}

//
// Structure buffer
//

vec3 StructureDecode(in vec4 Structure)
{
    vec3 Result = vec3(Structure.xy, Structure.z + Structure.w);
    return Result;
}

//
// Atmosphere
//

#if defined(FS)
float AtmosphereSampleDistribution(float m, float t)
{
    float Result = (1.0 - m) * t*t + m*t;
    return Result;
}

float AtmosphereNoise(vec2 P)
{
    vec3 P3 = fract(P.xyx * 0.1031);
    P3 += dot(P3, P3.yzx + vec3(33.33));
    float Result = abs(fract((P3.x + P3.y) * P3.z));
    return Result;
}

// NOTE(boti): g2 is g*g
float PhaseMie(in float g, in float g2, in float CosTheta)
{
    const float OneOver4Pi = 0.07957747;
#if 1
    float a = 1.0 + g2 - 2*g*CosTheta;
    float Denom = sqrt(a) * a;

    float Phase = OneOver4Pi * (1.0 - g2) / Denom;
#else
    float a = (1.0 - g) / (sqrt(1 + g2 - 2.0 * g * CosTheta));
    float Phase = OneOver4Pi * a*a*a;
#endif
    return(Phase);
}

float CalculateAtmosphere(v3 P, per_frame PerFrame, sampler2DArrayShadow ShadowMap)
{
    const int StepCount = 32;
    const float StepDistribution = 0.25;

    //v3 EndP = P * v3(1.0, 1.0, 0.999);
    float MaxDistance = 8.0;
    v3 V = normalize(P);
    v3 EndP = MaxDistance * V;

    float CosTheta = dot(V, PerFrame.SunV);

    const float g = 0.65;
    const float g2 = g*g;
    float PhaseIn = PhaseMie(g, g2, CosTheta);
    float PhaseOut = 1.0 - PhaseMie(g, g2, 1.0);

    float RayleighPhase = 0.059683103 * (1.0 + CosTheta); // constant is 3 / 16pi
    const vec3 BetaR0 = vec3(3.8e-6, 13.5e-6, 33.1e-6);
    const vec3 BetaM0 = vec3(21e-4);

    float Delta = AtmosphereNoise(0.5 * gl_FragCoord.xy);
    float InScatter = 0.0;
    uint CascadeIndex = 0;
    float Weight = StepDistribution;
    float dW = 2.0 * (1.0 - StepDistribution) / float(StepCount);

    mat4 CameraToShadow = PerFrame.CascadeViewProjection * PerFrame.CameraTransform;
    for (int i = 0; i < StepCount; i++)
    {
        float t = (i + Delta) / float(StepCount);
        t = AtmosphereSampleDistribution(StepDistribution, t);
        vec3 CurrentP = t * EndP;
        if (CurrentP.z >= P.z)
        {
            break;
        }

        while ((CascadeIndex < 3) && (CurrentP.z > PerFrame.CascadeMaxDistances[CascadeIndex]))
        {
            CascadeIndex++;
        }

        vec3 ShadowP = TransformPoint(CameraToShadow, CurrentP);
        if (CascadeIndex > 0)
        {
            ShadowP = PerFrame.CascadeScales[CascadeIndex - 1] * ShadowP + PerFrame.CascadeOffsets[CascadeIndex - 1];
        }
        vec4 ShadowCoord = vec4(0.5 * ShadowP.xy + vec2(0.5), float(CascadeIndex), ShadowP.z);
        float Shadow = texture(ShadowMap, ShadowCoord);

        InScatter += Weight * Shadow;
        Weight += dW;
    }

    float Norm = MaxDistance / (StepCount + 1.0);
    float Result = InScatter * PhaseIn * Norm;
    return Result;
}
#endif